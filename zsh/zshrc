# shellcheck shell=bash
#zmodload zsh/zprof && zprof

DOTFILES_DIR=$HOME/Repos/src/github.com/uetchy/dotfiles

# antibody
source <(antibody init)
antibody bundle denysdovhan/spaceship-prompt
antibody bundle zsh-users/zsh-syntax-highlighting
antibody bundle zsh-users/zsh-completions
antibody bundle uetchy/zsh-background-notify

# spaceship
SPACESHIP_PROMPT_ORDER=(
  user # Username section
  dir # Current directory section
  host # Hostname section
  git # Git section (git_branch + git_status)
  package # Package version
  # node          # Node.js section
  ruby # Ruby section
  # elixir        # Elixir section
  xcode # Xcode section
  swift # Swift section
  # golang        # Go section
  # php           # PHP section
  rust # Rust section
  # haskell       # Haskell Stack section
  # julia       # Julia section (Disabled)
  # docker      # Docker section (Disabled)
  aws # Amazon Web Services section
  venv # virtualenv section
  # conda         # conda virtualenv section
  # pyenv         # Pyenv section
  # dotnet        # .NET section
  # ember       # Ember.js section (Disabled)
  # kubecontext   # Kubectl context section
  exec_time # Execution time
  line_sep # Line break
  # battery # Battery level and status
  # vi_mode     # Vi-mode indicator (Disabled)
  # jobs # Background jobs indicator
  exit_code # Exit code section
  char # Prompt character
)

# Notification
setopt notify

# no beep sound
setopt no_beep

# Colors
export CLICOLOR=true

# Completion
autoload -U compinit
compinit -u

# completion caches
zstyle ':completion:*' use-cache on
# Ignore completion for non-existant commands
zstyle ':completion:*:functions' ignored-patterns '_*'
# cd will never select the parent directory
zstyle ':completion:*:cd:*' ignore-parents parent pwd
# insensitive completion
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}'
# Fuzzy completion
zstyle ':completion:*:approximate:*' max-errors 3 numeric
# ignore package-lock.json when completing
zstyle ':completion:*' file-patterns '^package-lock.json:source-files' '*:all-files'

# Language
export LANG="en_US.UTF-8"
export LC_ALL=$LANG
WORDCHARS='*?_-.[]~=&;!#$%^(){}<>'

# History
HISTFILE="$HOME/.zsh_history"
HISTSIZE=1000
SAVEHIST=2000
setopt share_history
setopt hist_ignore_dups
setopt hist_ignore_space
setopt hist_reduce_blanks

# Key binding
bindkey -e

# zsh
setopt nonomatch # no glob expansion for *, ?, [ and ]
setopt auto_cd   # cd without cd
setopt correct   # spelling correction for commands
alias reload="source $HOME/.zshrc"
alias editrc="vim $HOME/.zshrc"

# Homebrew
export PATH="/usr/local/sbin:$PATH"

# vim
export EDITOR="vim"

# ls
alias f="open ."
alias ls="exa"
alias la="ls -la --git"
alias lt="ls -lt"
alias tree="exa --tree -I node_modules"

# posix
sel() {
  cut -d"${2:-' '}" -f"${1:-1}"
}

# Wi-Fi
function restart_wifi() {
  sudo ifconfig en0 down
  sudo ifconfig en0 up
}

# Git
export GH="https://github.com/uetchy"
alias git="hub"
alias st="git status"
alias br="git branches"
alias remotes="git remotes"
alias gd="git diff"
alias pull="git pull --rebase"
alias push="git push"
alias push-origin-master="git push -u origin master"
alias recent="git recent"
alias stashall="git stash -u"
alias unstash="git stash pop"
alias gt="gittower ."
alias lg="lazygit"
alias delete-merged-branch='git branch --merged|egrep -v ''\*|master''|xargs git branch -d'
alias set-upstream="git branch -u"
alias set-upstream-origin-master="git branch --set-upstream-to=origin/master master"

git-update-upstream() {
  git fetch upstream
  git rebase upstream/master
}

git-checkout-upstream() {
  git checkout -b upstream upstream/master
}

add() {
  git add $1
  git status
}

gu() {
  local gtPrivateKeyPath=$(git config remote.origin.gtPrivateKeyPath)
  local privateKeyPath=${gtPrivateKeyPath:-$HOME/.ssh/id_rsa}
  local gitUser=$(git config user.name)
  local gitEmail=$(git config user.email)
  echo "Name: ${gitUser}"
  echo "Email: ${gitEmail}"
  echo "Key: ${privateKeyPath}"
  echo ""
  GIT_SSH_COMMAND="ssh -i ${privateKeyPath} -oIdentitiesOnly=yes" $@
}

git-bootstrap() {
  [ ! -d .git ] && git init
  license
  [ ! -f README.md ] && mkreadme
}

alias git-contributors="git shortlog -sn | awk -F '\t' 'BEGIN {print \"list of contributors, generated by \`git shortlog -sn\`.\n\"} {print \"- \" \$2}' | grep -Ev 'dependabot|travis|Greenkeeper'"

# GitHub
alias gh-repo="echo \${PWD#*\.*/}"
alias get="ghq get"

gh-readme() {
  hub api search/repositories?q=$1 | jq -r '.items[0].html_url' | fetch-readme | mdcat
}

gh-open() {
  git api search/repositories?q=$1 | jq -r '.items[0].html_url' | xargs open
}

gh-clone() {
  git api search/repositories?q=$1 | jq -r '.items[0].html_url' | xargs ghq get
}

# or `rel` would also works
releases() {
  local result=$(git api repos/$(gh-repo)/releases)
  jq -r '.[] | "[\(.tag_name)]\n\(.html_url)\n"' <<<"${result}"
}

## Release
alias release-it="release-it --git.tagName='v\${version}'"

# SSH
alias sak="ssh-add -K"
remote() {
  ssh $1 -t 'screen -qR'
}

forward() {
  ssh -L ${1}:localhost:${1} -N ${2}
}
alias forward-vnc="forward 5900"
alias forward-jupyter="forward 18888"

# remote worker scripts
export WORKER=com

sk() {
  echo 🚀 Syncing to $WORKER
  rsync -C --filter=":- .gitignore" --exclude=".git*" -avz . ${WORKER}:jobs/$(basename $PWD)
}

receive() {
  rsync -C --exclude=".git*" -avz ${WORKER}:jobs/$(basename $PWD)/$1 ./$1
  echo "📞 Receiving \"$1\" on $WORKER"
}

run() {
  ssh -t $WORKER "cd jobs/$(basename $PWD); zsh -ic \"$@\"" 2>/dev/null
  echo "🏃 Running \"$@\" on $WORKER"
}

skrun() {
  sk && echo '' && run $@
}

dive() {
  ssh -t $WORKER "cd jobs/$(basename $PWD); zsh"
  echo "🎯 Dive into jobs/$(basename "$PWD") on $WORKER"
}

## - Language
# Node
export PATH="/usr/local/lib/node_modules:$PATH"
alias npm-list="npm list -g --depth 0"
alias y="yarn"
alias yui="yarn upgrade-interactive"
alias yuil="yarn upgrade-interactive --latest"
alias yuilg="yarn global upgrade-interactive --latest"
alias ya="yarn add"
alias yad="yarn add -D"
alias yw="yarn workspaces"
alias np-precheck="f=\$(npm pack);tar -tf \$f; rm \$f"

export NVM_DIR="$HOME/.nvm"
export NODE_VERSIONS=$NVM_DIR/versions/node
export NODE_VERSION_PREFIX=v

enable_nvm() {
  source "$NVM_DIR/nvm.sh"  # This loads nvm
  source "$NVM_DIR/bash_completion"  # This loads nvm bash_completion
}

npm-bootstrap() {
  git-bootstrap

  local name=$(basename $PWD)
  local user=$(git config github.user)
  local gh_repo="https://github.com/$user/$name"
  [ ! -f package.json ] && yarn init -y
  [ "$(npe description)" = "undefined" ] && npe description $name
  [ "$(npe keywords)" = "undefined" ] && npe keywords $name
  [ "$(npe repository.type)" = "undefined" ] && npe repository.type git
  [ "$(npe repository.url)" = "undefined" ] && npe repository.url $gh_repo.git
  [ "$(npe homepage)" = "undefined" ] && npe homepage $gh_repo
  [ "$(npe bugs.url)" = "undefined" ] && npe bugs.url $gh_repo/issues
  [ "$(npe scripts.test)" = "undefined" ] && npe scripts.test "echo \"Error: no test specified\" && exit 1"
  fixpack
  [ ! -f .gitignore ] && gitignore add node

  if ! grep -Fxqs 'layout node' .envrc; then echo 'layout node' >>.envrc; fi
  direnv allow

}

# Python
export PIPENV_VENV_IN_PROJECT=true
export PIPENV_SKIP_LOCK=true
alias penv="pipenv"
alias pipreq="pip3 list --format=freeze --not-required > requirements.txt"
alias pip-update="pip3 list --outdated --format=json | jq '.[].name' | xargs pip3 install -U"
alias pip-list="pip3 list --not-required"
alias py="python3"
alias py2="python2"

pypi-versions() {
  curl -sL https://pypi.org/pypi/$1/json | jq -r '.releases|keys[]' | xargs semver
}

mkvenv() {
  if [ ! $@ ]; then
    pipenv install --three
  else
    export PATH="$HOME/.pyenv/shims:${PATH}"
    export PYENV_SHELL=zsh
    pipenv install --python $@
  fi
  if ! grep -Fxqs 'layout pipenv' .envrc; then echo 'layout pipenv' >>.envrc; fi
  direnv allow
}

rmvenv() {
  sed -i '' '/pipenv/d' ./.envrc
  direnv allow
  rm -rf .venv
}

# Go
export GOPATH="$HOME/Repos"
export PATH=$PATH:$GOPATH/bin
export GO111MODULE=on

# Rust
[ -d $HOME/.cargo ] && export PATH="$HOME/.cargo/bin:$PATH"

# Ruby
export PATH="/usr/local/opt/ruby/bin:$PATH"
alias be="bundle exec"
alias bi="bundle install --without production:staging --path vendor/bundle --binstubs vendor/bundle/bin"

gem-versions() {
  gem list --remote --all --pre "^${1}$"
}

## - App Settings
# direnv
#eval "$(direnv hook zsh)"
_direnv_hook() {
  eval "$("/usr/local/bin/direnv" export zsh)";
}
typeset -ag precmd_functions;
if [[ -z ${precmd_functions[(r)_direnv_hook]} ]]; then
  precmd_functions+=_direnv_hook;
fi
alias dea="direnv allow"

# mdfind
# https://stackoverflow.com/questions/30271328/how-do-i-get-mdfind-to-include-folder-matches-in-addition-to-files
mdfind-dir() {
  # c - match case-INsensitively
  # d - ignore diacritics
  mdfind -onlyin $HOME "kMDItemKind==\"Folder\" && kMDItemFSName==\"*${1}*\"cd" | grep -v "node_modules"
}

# Markdown
alias mat="mdcat -l"

# readme
alias mkreadme="yo standard-readme"

# du
alias volumestat="du -m -x -d 3 $HOME/Repos/src | awk '\$1 >= 500{print}'"

# translate
export JA_GTC_TARGET=ja
alias tr="translate"

# travis
[ -f $HOME/.travis/travis.sh ] && source $HOME/.travis/travis.sh

# license
# alias license="yo license --license MIT --name $(git config user.name) --email $(git config user.email) --website"
license() {
  local license_name=${@:-mit}
  local endpoint="https://raw.githubusercontent.com/licenses/license-templates/master/templates/${license_name}.txt"
  local year=$(date +%Y)
  local username=$(git config user.name)
  local email=$(git config user.email)
  local organization="${username} <${email}>"

  local license_body=$(curl -s ${endpoint})
  if [ $? != 0 ] || [ $license_body = "404: Not Found" ]; then
    echo "No such license: ${@}"
    return
  fi

  license_body=${license_body//"{{ year }}"/${year}}
  license_body=${license_body//"{{ organization }}"/${organization}}
  echo ${license_body} >/dev/stdout >LICENSE
}

# iTerm2
source "${HOME}/.iterm2_shell_integration.zsh"

# Visual Studio Code
vs() {
  if [ -z "$1" ]; then
    code .
  else
    if [[ "$1" == md:* ]]; then
      mdfind-dir "${1#md:}" | head -n1 | xargs code
    elif [[ "$1" == ghq:* ]]; then
      ghq list -p | grep ${1#ghq:} | head -n1 | xargs code
    else
      code $1
    fi
  fi
}

# Google
alias g="googler"
alias google="googler"
alias goto="googler -j"

glance() {
  googler -C --np --json $@ | jq '.[0]'
}

# Google Cloud Platform
if [ -d /usr/local/Caskroom/google-cloud-sdk ]; then
  source '/usr/local/Caskroom/google-cloud-sdk/latest/google-cloud-sdk/path.zsh.inc'
  source '/usr/local/Caskroom/google-cloud-sdk/latest/google-cloud-sdk/completion.zsh.inc'
fi

gj() {
  gcloud "$@" --format json
}

# Juno
alias juno="open -a Juno"

# Docker
alias d="docker"
alias dc="docker-compose"
alias da="docker ps -a"
alias di="docker images"
alias dim="docker images --format \"{{.Repository}}:{{.Tag}}\" | sort"
alias drm="docker ps -aqf status=exited | xargs docker rm -v"
alias drmi="docker images -qf dangling=true | xargs docker rmi"
alias drmii="docker images --format \"{{.Repository}}:{{.Tag}}\" | sort | peco | xargs docker rmi"

alias sandbox="docker run --rm -it --workdir /root -v \"\$HOME/Downloads:/root/Downloads\" uetchy/sandbox"

docker-tags() {
  curl -s https://registry.hub.docker.com/v2/repositories/$1/tags/ | jq -r '."results"[]["name"]'
}

# peco
function peco-src() {
  local selected_dir=$(ghq list | peco --query "$LBUFFER")
  if [ -n "$selected_dir" ]; then
    BUFFER="cd \"$(ghq root)/${selected_dir}\" && clear"
    zle accept-line
  fi
  zle redisplay
}
zle -N peco-src
bindkey '^r' peco-src

function peco-select-history() {
  BUFFER=$(fc -l -n 1 | tail -r | awk '!a[$0]++' | peco --query "$LBUFFER")
  CURSOR=$#BUFFER
  zle redisplay
}
zle -N peco-select-history
bindkey '^h' peco-select-history

_peco_mdfind() {
  result=$(mdfind-dir $@ | peco)
  if [ -n "$result" ]; then
    pushd $result
    clear
  fi
}
alias search="_peco_mdfind"

_peco_file() {
  local filepath=$(find . -type f | peco --prompt "FILE>")
  BUFFER=$LBUFFER\"$filepath\"$RBUFFER
  CURSOR=$#BUFFER
  zle redisplay
}
zle -N _peco_file
bindkey '^f' _peco_file

# YouTube
ydl() {
  youtube-dl "$1" -f mp4 --add-metadata
}

ydla() {
  youtube-dl "$1" -x --audio-format=mp3 --embed-thumbnail --add-metadata
}

# waifu2x
waifu2x() {
  docker run --rm -it -v $(pwd):/srv/waifu2x nothink/waifu2x -q -m noise_scale --noise_level 2 --scale_ratio "2.0" -i "/srv/waifu2x/$1" -o "/srv/waifu2x/${1%.*}-waifu2x.png"
}

export Books="$HOME/Library/Mobile Documents/iCloud~com~apple~iBooks/Documents"

# maintenance utils
update() {
  pushd $DOTFILES_DIR && git pull && popd
  reload
  HOMEBREW_INSTALL_CLEANUP=1 brew upgrade
  pip-update
  brew cask upgrade
  mas upgrade
  yarn global upgrade-interactive
  npm-check -gu
}
clearCache() {
  npm cache verify
  gem cleanup
  brew cleanup
  brew doctor
}
clearQLCache() {
  qlmanage -r
  qlmanage -r cache
}

#zprof
